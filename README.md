# Функциональное программирование. Лабораторная работа 1
## Climbing stairs
Дан алгоритм для подсчета количества уникальных способов подняться по лестнице из n ступенек, где за один шаг можно подняться на 1 или 2 ступеньки. Ключевая идея: количество способов подняться на ступеньку n равно сумме способов подняться на ступеньку n-1 и ступеньку n-2. 
Если вы находитесь на ступеньке n, вы могли прийти сюда:
- Сделав 1 шаг со ступеньки n-1
- Или сделав 2 шага со ступеньки n-2

Решение задачи на Python представлено в файле Task1
```
def climb_stairs(n):
    # Базовые случаи
    if n == 1:
        return 1
    if n == 2:
        return 2

    # Инициализация для n >= 3
    dp = [0] * (n + 1)
    dp[1] = 1  # только 1 способ: (1)
    dp[2] = 2  # 2 способа: (1,1) или (2)

    # Заполняем массив для ступенек от 3 до n
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```
## Jump Game II
Суть задачи в нахождении минимального количества прыжков от начала массива до его конца, где каждый элемент массива показывает максимальную длину прыжка из этой позиции.
Мы используем жадный подход, который на каждом шаге выбирает прыжок, который позволит нам достичь максимально далекой позиции.
Переменные:
- jumps - счетчик количества прыжков
- current_end - текущая граница достижимой области после последнего прыжка
- farthest - самая дальняя позиция, которую мы можем достичь из текущей области.

Мы проходим по массиву и на каждом шаге обновляем farthest - самую дальнюю позицию, которую можем достичь. Когда достигаем конца текущей достижимой области (current_end), делаем прыжок и обновляем границу. Алгоритм гарантирует минимальное количество прыжков, потому что мы всегда прыгаем, когда это необходимо, и выбираем прыжок, который дает максимальное покрытие.
Решение задачи на Python представлено в файле Task2.
```
def jump(nums):
    n = len(nums)
    if n <= 1:
        return 0

    jumps = 0
    current_end = 0
    farthest = 0

    for i in range(n - 1):
        farthest = max(farthest, i + nums[i])

        if i == current_end:
            jumps += 1
            current_end = farthest

            if current_end >= n - 1:
                break

    return jumps
```
## Pascal's Triangle II
В задаче представлен треугольник Паскаля. Это математическая конструкция, где:
- Первая строка: 1
- Каждая следующая строка: начинается и заканчивается единицей.
- Каждое внутреннее число = сумме двух чисел над ним.

Целью задачи является поиск одной конкретной строки треугольника Паскаля (по индексу).
Решение задачи на Python представлено в файле Task3. Алгоритм строит строки последовательно, пока не достигнет нужной.
```
def getRow(rowIndex):
    row = [1]

    for i in range(1, rowIndex + 1):
        # Создаем новую строку на основе предыдущей
        new_row = [1]  # Первый элемент всегда 1

        # Заполняем средние элементы
        for j in range(1, i):
            new_row.append(row[j - 1] + row[j])

        new_row.append(1)  # Последний элемент всегда 1
        row = new_row

    return row
```
## Best time to buy and sell stock 1
Задача заключается в нахождении максимальной прибыли от одной сделки "купить-продать" на исторических данных цен акций.
Условия:
- Можно совершить только одну транзакцию (купить один раз + продать один раз)
- Покупать нужно до продажи
- Нужно выбрать оптимальные дни для покупки и продажи.

Мы проходим по массиву цен всего один раз, отслеживая две ключевые величины:
- Минимальная цена, которую мы видели до текущего дня
- Максимальная прибыль, которую мы можем получить

Для каждой цены проверяем, не является ли она новой минимальной ценой. Если да - обновляем min_price. Если нет - рассчитываем прибыль от продажи по текущей цене (купив по min_price). Если эта прибыль больше текущей max_profit - обновляем максимум
Решение задачи на Python представлено в файле Task4.
```
def maxProfit(prices):
    min_price = float('inf')  # Начинаем с очень большого числа
    max_profit = 0

    for price in prices:
        # Обновляем минимальную цену, если нашли меньшую
        if price < min_price:
            min_price = price
        # Рассчитываем потенциальную прибыль и обновляем максимальную
        else:
            profit = price - min_price
            if profit > max_profit:
                max_profit = profit

    return max_profit
```
## Best time to buy and sell stock 2
Задача заключается в нахождении максимальной прибыли при возможности совершать неограниченное количество сделок с акциями.
Условия:
- Можно покупать и продавать многократно
- Можно совершать сделки в один и тот же день (продать и сразу купить)
- Одновременно можно держать только одну акцию
- Нужно купить перед продажей.

Сложную задачу многократной торговли свели к простой сумме локальных прибылей. На каждом шаге берём локально оптимальное решение (все положительные разницы). В дни, когда цена падает, мы просто не торгуем.
Решение задачи на Python представлено в файле Task5.
```
def maxProfit(prices):
    max_profit = 0

    for i in range(1, len(prices)):
        # Если цена сегодня выше, чем вчера, добавляем разницу к прибыли
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1]

    return max_profit
```
